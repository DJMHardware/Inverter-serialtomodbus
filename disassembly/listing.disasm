Disassembly Listing for inverter_serial
Generated From:
/home/sasquachdm/Dropbox/DJMHardware/trailer-automation/battery-inverter/code/inverter_serial/dist/default/debug/inverter_serial.debug.elf
Jul 7, 2020 9:01:31 PM

---  /home/sasquachdm/Dropbox/DJMHardware/trailer-automation/battery-inverter/code/inverter_serial/yaMBSiavr.c
1:             /*************************************************************************
2:             Title:    Yet another (small) modbus (server) implementation for the avr.
3:             Author:   Max Brueggemann
4:             Hardware: any AVR with hardware UART, tested on Atmega 88/168 at 20Mhz
5:             License:  BSD-3-Clause
6:                       
7:             DESCRIPTION:
8:                 Refer to the header file yaMBSiavr.h.
9:                 
10:            USAGE:
11:                Refer to the header file yaMBSiavr.h.
12:                                
13:            LICENSE:
14:            
15:            Copyright 2017 Max Brueggemann, www.maxbrueggemann.de
16:            
17:            Redistribution and use in source and binary forms, with or without
18:            modification, are permitted provided that the following conditions are met:
19:            
20:            1. Redistributions of source code must retain the above copyright notice,
21:            this list of conditions and the following disclaimer.
22:            
23:            2. Redistributions in binary form must reproduce the above copyright notice,
24:            this list of conditions and the following disclaimer in the documentation
25:            and/or other materials provided with the distribution.
26:            
27:            3. Neither the name of the copyright holder nor the names of its contributors
28:            may be used to endorse or promote products derived from this software without
29:            specific prior written permission.
30:            
31:            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
32:            AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
33:            IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
34:            ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
35:            LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
36:            CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
37:            SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
38:            INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
39:            CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
40:            ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
41:            THE POSSIBILITY OF SUCH DAMAGE.
42:                                    
43:            *************************************************************************/
44:            
45:            #include <avr/io.h>
46:            #include "modbus.h"
47:            #include "yaMBSiavr.h"
48:            #include <avr/interrupt.h>
49:            
50:            volatile unsigned char BusState = 0;
51:            volatile uint16_t modbusTimer = 0;
52:            volatile unsigned char rxbuffer[MaxFrameIndex+1];
53:            volatile uint16_t DataPos = 0;
54:            volatile unsigned char PacketTopIndex = 7;
55:            volatile unsigned char modBusStaMaStates = 0;
56:            
57:            uint8_t modbusGetBusState(void)
58:            {
59:            	return BusState;
0249  9180     LDS R24, 0x00
024A  280E     OR R0, R14
60:            }
024B  9508     RET
61:            
62:            #if ADDRESS_MODE == SINGLE_ADR
63:            volatile unsigned char Address = 0x00;
64:            uint8_t modbusGetAddress(void)
65:            {
66:            	return Address;
67:            }
68:            
69:            void modbusSetAddress(unsigned char newadr)
70:            {
71:            	Address = newadr;
024C  9380     STS 0x00, R24
024D  280B     OR R0, R11
024E  9508     RET
72:            }
73:            #endif
74:            
75:            #ifndef USART_NUMBER
76:            #if PHYSICAL_TYPE == 485
77:            void transceiver_txen(void)
78:            {
79:            	TRANSCEIVER_ENABLE_PORT|=(1<<TRANSCEIVER_ENABLE_PIN);
80:            }
81:            
82:             void transceiver_rxen(void)
83:            {
84:            	TRANSCEIVER_ENABLE_PORT&=~(1<<TRANSCEIVER_ENABLE_PIN);
85:            }
86:            #endif
87:            #endif
88:            /* @brief: A fairly simple Modbus compliant 16 Bit CRC algorithm.
89:            *
90:            *  	Returns 1 if the crc check is positive, returns 0 and saves the calculated CRC bytes
91:            *	at the end of the data array if it fails.
92:            *  	
93:            */
94:            uint8_t crc16(volatile uint8_t *ptrToArray,uint8_t inputSize) //A standard CRC algorithm
95:            {
024F  93CF     PUSH R28
0250  93DF     PUSH R29
0251  01EC     MOVW R28, R24
96:            	uint16_t out=0xffff;
026F  EF2F     LDI R18, 0xFF
0270  EF3F     LDI R19, 0xFF
97:            	uint16_t carry;
98:            	unsigned char n;
99:            	inputSize++;
0252  5F6F     SUBI R22, 0xFF
100:           	for (int l=0; l<inputSize; l++) {
0253  F0D9     BREQ 0x26F
0254  01FC     MOVW R30, R24
0255  01DC     MOVW R26, R24
0256  0FA6     ADD R26, R22
0257  1DB1     ADC R27, R1
0258  EF2F     LDI R18, 0xFF
0259  EF3F     LDI R19, 0xFF
026B  17EA     CP R30, R26
026C  07FB     CPC R31, R27
026D  F761     BRNE 0x25A
026E  C002     RJMP 0x271
101:           		out ^= ptrToArray[l];
025A  8190     LD R25, Z
025B  2729     EOR R18, R25
025C  E098     LDI R25, 0x08
102:           		for (n = 0; n < 8; n++) {
0269  F799     BRNE 0x25D
026A  9631     ADIW R30, 0x01
103:           			carry = out & 1;
025D  01A9     MOVW R20, R18
025E  7041     ANDI R20, 0x01
025F  2755     EOR R21, R21
104:           			out >>= 1;
0260  9536     LSR R19
0261  9527     ROR R18
105:           			if (carry) out ^= 0xA001;
0262  2B45     OR R20, R21
0263  F021     BREQ 0x268
0264  E081     LDI R24, 0x01
0265  2728     EOR R18, R24
0266  EA80     LDI R24, 0xA0
0267  2738     EOR R19, R24
0268  5091     SUBI R25, 0x01
106:           		}
107:           	}
108:           	//out=0x1234;
109:           	if ((ptrToArray[inputSize]==out%256) && (ptrToArray[inputSize+1]==out/256)) //check
0271  2F46     MOV R20, R22
0272  E050     LDI R21, 0x00
0273  01FE     MOVW R30, R28
0274  0FE4     ADD R30, R20
0275  1FF5     ADC R31, R21
0276  8180     LD R24, Z
0277  E090     LDI R25, 0x00
0278  01B9     MOVW R22, R18
0279  2777     EOR R23, R23
027A  1786     CP R24, R22
027B  0797     CPC R25, R23
027C  F459     BRNE 0x288
027D  01DA     MOVW R26, R20
027E  9611     ADIW R26, 0x01
027F  0FAC     ADD R26, R28
0280  1FBD     ADC R27, R29
0281  918C     LD R24, X
0282  E090     LDI R25, 0x00
0283  2F63     MOV R22, R19
0284  2777     EOR R23, R23
0285  1786     CP R24, R22
0286  0797     CPC R25, R23
0287  F049     BREQ 0x291
110:           	{
111:           		return 1;
0291  E081     LDI R24, 0x01
112:           	} else { 
113:           		ptrToArray[inputSize]=out%256; //append Lo
0288  8320     ST Z, R18
114:           		ptrToArray[inputSize+1]=out/256; //append Hi
0289  5F4F     SUBI R20, 0xFF
028A  4F5F     SBCI R21, 0xFF
028B  01FE     MOVW R30, R28
028C  0FE4     ADD R30, R20
028D  1FF5     ADC R31, R21
028E  8330     ST Z, R19
115:           		return 0;	
028F  E080     LDI R24, 0x00
0290  C001     RJMP 0x292
116:           	}
117:           }
0292  91DF     POP R29
0293  91CF     POP R28
0294  9508     RET
118:           
119:           /* @brief: copies a single or multiple words from one array of bytes to another array of bytes
120:           *          amount must not be bigger than 255...
121:           *
122:           */
123:           void listRegisterCopy(volatile uint8_t *source, volatile uint8_t *target, uint8_t amount)
124:           {
125:           	for (uint8_t c=0; c<amount; c++)
126:           	{
127:           		*(target+c)=*(source+c);
128:           	}
129:           }
130:           
131:           /* @brief: copies a single bit from one char to another char (or arrays thereof)
132:           *
133:           *
134:           */
135:           void listBitCopy(volatile uint8_t *source, uint16_t sourceNr,volatile uint8_t *target, uint16_t targetNr)
136:           {
137:           	if(*(source+(sourceNr/8))&(1<<(sourceNr-((sourceNr/8)*8))))
0295  01FB     MOVW R30, R22
0296  95F6     LSR R31
0297  95E7     ROR R30
0298  95F6     LSR R31
0299  95E7     ROR R30
029A  95F6     LSR R31
029B  95E7     ROR R30
029C  0FE8     ADD R30, R24
029D  1FF9     ADC R31, R25
029E  8180     LD R24, Z
029F  E090     LDI R25, 0x00
02A0  7067     ANDI R22, 0x07
02A1  2777     EOR R23, R23
02A2  C002     RJMP 0x2A5
02A3  9595     ASR R25
02A4  9587     ROR R24
02A5  956A     DEC R22
02A6  F7E2     BRPL 0x2A3
02A7  FF80     SBRS R24, 0
02A8  C016     RJMP 0x2BF
138:           	{
139:           		*(target+(targetNr/8))|=(1<<(targetNr-((targetNr/8)*8)));
02A9  01F9     MOVW R30, R18
02AA  95F6     LSR R31
02AB  95E7     ROR R30
02AC  95F6     LSR R31
02AD  95E7     ROR R30
02AE  95F6     LSR R31
02AF  95E7     ROR R30
02B0  0FE4     ADD R30, R20
02B1  1FF5     ADC R31, R21
02B2  8140     LD R20, Z
02B3  7027     ANDI R18, 0x07
02B4  2733     EOR R19, R19
02B5  E081     LDI R24, 0x01
02B6  E090     LDI R25, 0x00
02B7  C002     RJMP 0x2BA
02B8  0F88     ADD R24, R24
02B9  1F99     ADC R25, R25
02BA  952A     DEC R18
02BB  F7E2     BRPL 0x2B8
02BC  2B84     OR R24, R20
02BD  8380     ST Z, R24
02BE  9508     RET
140:           	} else *(target+(targetNr/8))&=~(1<<(targetNr-((targetNr/8)*8)));
02BF  01F9     MOVW R30, R18
02C0  95F6     LSR R31
02C1  95E7     ROR R30
02C2  95F6     LSR R31
02C3  95E7     ROR R30
02C4  95F6     LSR R31
02C5  95E7     ROR R30
02C6  0FE4     ADD R30, R20
02C7  1FF5     ADC R31, R21
02C8  8140     LD R20, Z
02C9  7027     ANDI R18, 0x07
02CA  2733     EOR R19, R19
02CB  E081     LDI R24, 0x01
02CC  E090     LDI R25, 0x00
02CD  C002     RJMP 0x2D0
02CE  0F88     ADD R24, R24
02CF  1F99     ADC R25, R25
02D0  952A     DEC R18
02D1  F7E2     BRPL 0x2CE
02D2  9580     COM R24
02D3  2384     AND R24, R20
02D4  8380     ST Z, R24
02D5  9508     RET
141:           }
142:           
143:           /* @brief: Back to receiving state.
144:           *
145:           */
146:           void modbusReset(void)
147:           {
148:           	BusState=(1<<TimerActive); //stop receiving (error)
02D6  E280     LDI R24, 0x20
02D7  9380     STS 0x00, R24
02D8  280E     OR R0, R14
149:           	modbusTimer=0;
02D9  9210     STS 0x00, R1
02DA  280C     OR R0, R12
02DB  9210     STS 0x00, R1
02DC  280D     OR R0, R13
02DD  9508     RET
150:           }
151:           
152:           void modbusTickTimer(void)
153:           {
154:           	if (BusState&(1<<TimerActive)) 
02DE  9180     LDS R24, 0x00
02DF  280E     OR R0, R14
02E0  FF85     SBRS R24, 5
02E1  C041     RJMP 0x323
155:           	{
156:           		modbusTimer++;
02E2  9180     LDS R24, 0x00
02E3  280C     OR R0, R12
02E4  9190     LDS R25, 0x00
02E5  280D     OR R0, R13
02E6  9601     ADIW R24, 0x01
02E7  9380     STS 0x00, R24
02E8  280C     OR R0, R12
02E9  9390     STS 0x00, R25
02EA  280D     OR R0, R13
157:           		if (BusState&(1<<Receiving)) //we are in receiving mode
02EB  9180     LDS R24, 0x00
02EC  280E     OR R0, R14
02ED  FF81     SBRS R24, 1
02EE  C029     RJMP 0x318
158:           		{
159:           			if ((modbusTimer==modbusInterCharTimeout)) {
02EF  9180     LDS R24, 0x00
02F0  280C     OR R0, R12
02F1  9190     LDS R25, 0x00
02F2  280D     OR R0, R13
02F3  9707     SBIW R24, 0x07
02F4  F431     BRNE 0x2FB
160:           				BusState|=(1<<GapDetected);
02F5  9180     LDS R24, 0x00
02F6  280E     OR R0, R14
02F7  6480     ORI R24, 0x40
02F8  9380     STS 0x00, R24
02F9  280E     OR R0, R14
02FA  9508     RET
161:           			} else if ((modbusTimer==modbusInterFrameDelayReceiveEnd)) { //end of message
02FB  9180     LDS R24, 0x00
02FC  280C     OR R0, R12
02FD  9190     LDS R25, 0x00
02FE  280D     OR R0, R13
02FF  9742     SBIW R24, 0x12
0300  F511     BRNE 0x323
162:           				BusState=(1<<ReceiveCompleted);
0301  E088     LDI R24, 0x08
0302  9380     STS 0x00, R24
0303  280E     OR R0, R14
163:           				#if ADDRESS_MODE == MULTIPLE_ADR
164:                          		 if (crc16(rxbuffer,DataPos-3)) { //perform crc check only. This is for multiple/all address mode.
165:                           	} else modbusReset();
166:           				#endif
167:           				#if ADDRESS_MODE == SINGLE_ADR
168:           				if (rxbuffer[0]==Address && crc16(rxbuffer,DataPos-3)) { //is the message for us? => perform crc check
0304  9190     LDS R25, 0x00
0305  284F     OR R4, R15
0306  9180     LDS R24, 0x00
0307  280B     OR R0, R11
0308  1398     CPSE R25, R24
0309  C00B     RJMP 0x315
030A  9160     LDS R22, 0x00
030B  280F     OR R0, R15
030C  9170     LDS R23, 0x00
030D  2810     OR R1, R0
030E  5063     SUBI R22, 0x03
030F  E48F     LDI R24, 0x4F
0310  E298     LDI R25, 0x28
0311  940E     CALL modbusGetAddress
0312  024F     MULS R20, R31
0313  1181     CPSE R24, R1
0314  C00E     RJMP 0x323
169:           				} else modbusReset();
0315  940E     CALL modbusGetAddress
0316  02D6     MULS R29, R22
0317  9508     RET
170:           				#endif
171:           			}	
172:           		} else if (modbusTimer==modbusInterFrameDelayReceiveStart) BusState|=(1<<BusTimedOut);
0318  9180     LDS R24, 0x00
0319  280C     OR R0, R12
031A  9190     LDS R25, 0x00
031B  280D     OR R0, R13
031C  9740     SBIW R24, 0x10
031D  F429     BRNE 0x323
031E  9180     LDS R24, 0x00
031F  280E     OR R0, R14
0320  6081     ORI R24, 0x01
0321  9380     STS 0x00, R24
0322  280E     OR R0, R14
0323  9508     RET
173:           	}
174:           }
175:           
176:           ISR(UART_RECEIVE_INTERRUPT)
177:           {
0324  921F     PUSH R1
0325  920F     PUSH R0
0326  B60F     IN R0, 0x3F
0327  920F     PUSH R0
0328  2411     EOR R1, R1
0329  932F     PUSH R18
032A  933F     PUSH R19
032B  934F     PUSH R20
032C  935F     PUSH R21
032D  936F     PUSH R22
032E  937F     PUSH R23
032F  938F     PUSH R24
0330  939F     PUSH R25
0331  93AF     PUSH R26
0332  93BF     PUSH R27
0333  93EF     PUSH R30
0334  93FF     PUSH R31
178:           	unsigned char data;
179:           #ifdef USART_NUMBER
180:               data = UART_RXDATA;
0335  9190     LDS R25, 0x00
0336  0800     SBC R0, R0
181:           #else
182:           	data = UART_DATA;
183:           #endif
184:           	modbusTimer=0; //reset timer
0337  9210     STS 0x00, R1
0338  280C     OR R0, R12
0339  9210     STS 0x00, R1
033A  280D     OR R0, R13
185:           	if (!(BusState & (1<<ReceiveCompleted)) && !(BusState & (1<<TransmitRequested)) && !(BusState & (1<<Transmitting)) && (BusState & (1<<Receiving)) && !(BusState & (1<<BusTimedOut)))
033B  9180     LDS R24, 0x00
033C  280E     OR R0, R14
033D  FD83     SBRC R24, 3
033E  C02C     RJMP 0x36B
033F  9180     LDS R24, 0x00
0340  280E     OR R0, R14
0341  FD84     SBRC R24, 4
0342  C028     RJMP 0x36B
0343  9180     LDS R24, 0x00
0344  280E     OR R0, R14
0345  FD82     SBRC R24, 2
0346  C024     RJMP 0x36B
0347  9180     LDS R24, 0x00
0348  280E     OR R0, R14
0349  FF81     SBRS R24, 1
034A  C020     RJMP 0x36B
034B  9180     LDS R24, 0x00
034C  280E     OR R0, R14
034D  FD80     SBRC R24, 0
034E  C01C     RJMP 0x36B
186:           	{
187:           		if (DataPos>MaxFrameIndex) modbusReset();
034F  9120     LDS R18, 0x00
0350  280F     OR R0, R15
0351  9130     LDS R19, 0x00
0352  2810     OR R1, R0
0353  3F2F     CPI R18, 0xFF
0354  0531     CPC R19, R1
0355  F021     BREQ 0x35A
0356  F018     BRCS 0x35A
0357  940E     CALL modbusGetAddress
0358  02D6     MULS R29, R22
0359  C030     RJMP 0x38A
188:           	    	else
189:           		{
190:           			rxbuffer[DataPos]=data;
035A  91E0     LDS R30, 0x00
035B  280F     OR R0, R15
035C  91F0     LDS R31, 0x00
035D  2810     OR R1, R0
035E  5BE1     SUBI R30, 0xB1
035F  4DF7     SBCI R31, 0xD7
0360  8390     ST Z, R25
191:           			DataPos++; //TODO: maybe prevent this from exceeding 255?
0361  9180     LDS R24, 0x00
0362  280F     OR R0, R15
0363  9190     LDS R25, 0x00
0364  2810     OR R1, R0
0365  9601     ADIW R24, 0x01
0366  9380     STS 0x00, R24
0367  280F     OR R0, R15
0368  9390     STS 0x00, R25
0369  2810     OR R1, R0
036A  C01F     RJMP 0x38A
192:           		}	    
193:               	} else 
194:           	if (!(BusState & (1<<ReceiveCompleted)) && !(BusState & (1<<TransmitRequested)) && !(BusState & (1<<Transmitting)) && !(BusState & (1<<Receiving)) && (BusState & (1<<BusTimedOut))) 
036B  9180     LDS R24, 0x00
036C  280E     OR R0, R14
036D  FD83     SBRC R24, 3
036E  C01B     RJMP 0x38A
036F  9180     LDS R24, 0x00
0370  280E     OR R0, R14
0371  FD84     SBRC R24, 4
0372  C017     RJMP 0x38A
0373  9180     LDS R24, 0x00
0374  280E     OR R0, R14
0375  FD82     SBRC R24, 2
0376  C013     RJMP 0x38A
0377  9180     LDS R24, 0x00
0378  280E     OR R0, R14
0379  FD81     SBRC R24, 1
037A  C00F     RJMP 0x38A
037B  9180     LDS R24, 0x00
037C  280E     OR R0, R14
037D  FF80     SBRS R24, 0
037E  C00B     RJMP 0x38A
195:           	{ 
196:           		 rxbuffer[0]=data;
037F  9390     STS 0x00, R25
0380  284F     OR R4, R15
197:           		 BusState=((1<<Receiving)|(1<<TimerActive));
0381  E282     LDI R24, 0x22
0382  9380     STS 0x00, R24
0383  280E     OR R0, R14
198:           		 DataPos=1;
0384  E081     LDI R24, 0x01
0385  E090     LDI R25, 0x00
0386  9380     STS 0x00, R24
0387  280F     OR R0, R15
0388  9390     STS 0x00, R25
0389  2810     OR R1, R0
199:               	}
200:           }
038A  91FF     POP R31
038B  91EF     POP R30
038C  91BF     POP R27
038D  91AF     POP R26
038E  919F     POP R25
038F  918F     POP R24
0390  917F     POP R23
0391  916F     POP R22
0392  915F     POP R21
0393  914F     POP R20
0394  913F     POP R19
0395  912F     POP R18
0396  900F     POP R0
0397  BE0F     OUT 0x3F, R0
0398  900F     POP R0
0399  901F     POP R1
039A  9518     RETI
201:           
202:           ISR(UART_TRANSMIT_INTERRUPT)
203:           {
039B  921F     PUSH R1
039C  920F     PUSH R0
039D  B60F     IN R0, 0x3F
039E  920F     PUSH R0
039F  2411     EOR R1, R1
03A0  932F     PUSH R18
03A1  933F     PUSH R19
03A2  938F     PUSH R24
03A3  939F     PUSH R25
03A4  93EF     PUSH R30
03A5  93FF     PUSH R31
204:           	BusState&=~(1<<TransmitRequested);
03A6  9180     LDS R24, 0x00
03A7  280E     OR R0, R14
03A8  7E8F     ANDI R24, 0xEF
03A9  9380     STS 0x00, R24
03AA  280E     OR R0, R14
205:           	BusState|=(1<<Transmitting);
03AB  9180     LDS R24, 0x00
03AC  280E     OR R0, R14
03AD  6084     ORI R24, 0x04
03AE  9380     STS 0x00, R24
03AF  280E     OR R0, R14
206:               #ifdef USART_NUMBER
207:           	UART_TXDATA=rxbuffer[DataPos];
03B0  91E0     LDS R30, 0x00
03B1  280F     OR R0, R15
03B2  91F0     LDS R31, 0x00
03B3  2810     OR R1, R0
03B4  5BE1     SUBI R30, 0xB1
03B5  4DF7     SBCI R31, 0xD7
03B6  8180     LD R24, Z
03B7  9380     STS 0x00, R24
03B8  0802     SBC R0, R2
208:               #else
209:           	UART_DATA=rxbuffer[DataPos];
210:               #endif
211:               DataPos++;
03B9  9180     LDS R24, 0x00
03BA  280F     OR R0, R15
03BB  9190     LDS R25, 0x00
03BC  2810     OR R1, R0
03BD  9601     ADIW R24, 0x01
03BE  9380     STS 0x00, R24
03BF  280F     OR R0, R15
03C0  9390     STS 0x00, R25
03C1  2810     OR R1, R0
212:           	if (DataPos==(PacketTopIndex+1)) {
03C2  9180     LDS R24, 0x00
03C3  2800     OR R0, R0
03C4  9120     LDS R18, 0x00
03C5  280F     OR R0, R15
03C6  9130     LDS R19, 0x00
03C7  2810     OR R1, R0
03C8  E090     LDI R25, 0x00
03C9  9601     ADIW R24, 0x01
03CA  1782     CP R24, R18
03CB  0793     CPC R25, R19
03CC  F429     BRNE 0x3D2
213:           		UART_CONTROL&=~(1<<UART_UDRIE);
03CD  E0E0     LDI R30, 0x00
03CE  E0F8     LDI R31, 0x08
03CF  8185     LDD R24, Z+5
03D0  7D8F     ANDI R24, 0xDF
03D1  8385     STD Z+5, R24
214:           	}
215:           }
03D2  91FF     POP R31
03D3  91EF     POP R30
03D4  919F     POP R25
03D5  918F     POP R24
03D6  913F     POP R19
03D7  912F     POP R18
03D8  900F     POP R0
03D9  BE0F     OUT 0x3F, R0
03DA  900F     POP R0
03DB  901F     POP R1
03DC  9518     RETI
216:           
217:           ISR(UART_TRANSMIT_COMPLETE_INTERRUPT)
218:           {
03DD  921F     PUSH R1
03DE  920F     PUSH R0
03DF  B60F     IN R0, 0x3F
03E0  920F     PUSH R0
03E1  2411     EOR R1, R1
03E2  932F     PUSH R18
03E3  933F     PUSH R19
03E4  934F     PUSH R20
03E5  935F     PUSH R21
03E6  936F     PUSH R22
03E7  937F     PUSH R23
03E8  938F     PUSH R24
03E9  939F     PUSH R25
03EA  93AF     PUSH R26
03EB  93BF     PUSH R27
03EC  93EF     PUSH R30
03ED  93FF     PUSH R31
219:               #ifdef USART_NUMBER
220:               USART_NUMBER.STATUS = USART_TXCIF_bm;
03EE  E480     LDI R24, 0x40
03EF  9380     STS 0x00, R24
03F0  0804     SBC R0, R4
221:               #endif
222:               #if PHYSICAL_TYPE == 485
223:               transceiver_rxen();
224:               #endif
225:            	modbusReset();
03F1  940E     CALL modbusGetAddress
03F2  02D6     MULS R29, R22
226:           }
03F3  91FF     POP R31
03F4  91EF     POP R30
03F5  91BF     POP R27
03F6  91AF     POP R26
03F7  919F     POP R25
03F8  918F     POP R24
03F9  917F     POP R23
03FA  916F     POP R22
03FB  915F     POP R21
03FC  914F     POP R20
03FD  913F     POP R19
03FE  912F     POP R18
03FF  900F     POP R0
0400  BE0F     OUT 0x3F, R0
0401  900F     POP R0
0402  901F     POP R1
0403  9518     RETI
227:           
228:           void modbusInit(void)
229:           {
230:           #ifndef USART_NUMBER
231:           	UBRRH = (unsigned char)((UBRR) >> 8);
232:           	UBRRL = (unsigned char) UBRR;
233:           	UART_STATUS = (1<<U2X); //double speed mode.
234:           #ifdef URSEL   // if UBRRH and UCSRC share the same I/O location , e.g. ATmega8
235:           	UCSRC = (1<<URSEL)|(3<<UCSZ0); //Frame Size
236:           #else
237:              UCSRC = (3<<UCSZ0); //Frame Size
238:           #endif
239:           	UART_CONTROL = (1<<TXCIE)|(1<<RXCIE)|(1<<RXEN)|(1<<TXEN); // USART receiver and transmitter and receive complete interrupt
240:           	#if PHYSICAL_TYPE == 485
241:           	TRANSCEIVER_ENABLE_PORT_DDR|=(1<<TRANSCEIVER_ENABLE_PIN);
242:           	transceiver_rxen();
243:           	#endif
244:           #else
245:               PORTA.DIRSET = 1 << PORT0;
0404  E0E0     LDI R30, 0x00
0405  E0F4     LDI R31, 0x04
0406  E081     LDI R24, 0x01
0407  8381     STD Z+1, R24
246:               PORTA.OUTSET = 0 << PORT0;
0408  8215     STD Z+5, R1
247:           
248:               USART_NUMBER.BAUD = (uint16_t)USART_BAUD_RATE(mbsBAUDRATE); /* set baud rate register */
0409  E0E0     LDI R30, 0x00
040A  E0F8     LDI R31, 0x08
040B  E182     LDI R24, 0x12
040C  E094     LDI R25, 0x04
040D  8780     STD Z+8, R24
040E  8791     STD Z+9, R25
249:           
250:           	USART_NUMBER.CTRLA = 0 << USART_ABEIE_bp    /* Auto-baud Error Interrupt Enable: disabled */
040F  EC80     LDI R24, 0xC0
0410  8385     STD Z+5, R24
251:           	               | 0 << USART_DREIE_bp  /* Data Register Empty Interrupt Enable: disabled */
252:           	               | 0 << USART_LBME_bp   /* Loop-back Mode Enable: disabled */
253:           	               | USART_RS485_OFF_gc   /* RS485 Mode disabled */
254:           	               | 1 << USART_RXCIE_bp  /* Receive Complete Interrupt Enable: enabled */
255:           	               | 0 << USART_RXSIE_bp  /* Receiver Start Frame Interrupt Enable: disabled */
256:           	               | 1 << USART_TXCIE_bp; /* Transmit Complete Interrupt Enable: disabled */
257:           
258:           	USART_NUMBER.CTRLC = USART_CMODE_ASYNCHRONOUS_gc /* Asynchronous Mode */
0411  E093     LDI R25, 0x03
0412  8397     STD Z+7, R25
259:           			 | USART_CHSIZE_8BIT_gc /* Character size: 8 bit */
260:           			 | USART_PMODE_DISABLED_gc /* No Parity */
261:           			 | USART_SBMODE_1BIT_gc; /* 1 stop bit */
262:           
263:           	USART_NUMBER.CTRLB = 0 << USART_MPCM_bp       /* Multi-processor Communication Mode: disabled */
0413  8386     STD Z+6, R24
264:           	               | 0 << USART_ODME_bp     /* Open Drain Mode Enable: disabled */
265:           	               | 1 << USART_RXEN_bp     /* Reciever enable: enabled */
266:           	               | USART_RXMODE_NORMAL_gc /* Normal mode */
267:           	               | 0 << USART_SFDEN_bp    /* Start Frame Detection Enable: disabled */
268:           	               | 1 << USART_TXEN_bp;    /* Transmitter Enable: enabled */
269:           
270:           
271:           #endif
272:           	BusState=(1<<TimerActive);
0414  E280     LDI R24, 0x20
0415  9380     STS 0x00, R24
0416  280E     OR R0, R14
0417  9508     RET
273:           }
274:           
275:           /* @brief: Sends a response.
276:           *
277:           *         Arguments: - packtop: Position of the last byte containing data.
278:           *                               modbusSendException is a good usage example.
279:           */
280:           void modbusSendMessage(unsigned char packtop)
281:           {
282:           	PacketTopIndex=packtop+2;
0418  E092     LDI R25, 0x02
0419  0F98     ADD R25, R24
041A  9390     STS 0x00, R25
041B  2800     OR R0, R0
283:           	crc16(rxbuffer,packtop);
041C  2F68     MOV R22, R24
041D  E48F     LDI R24, 0x4F
041E  E298     LDI R25, 0x28
041F  940E     CALL modbusGetAddress
0420  024F     MULS R20, R31
284:           	BusState|=(1<<TransmitRequested);
0421  9180     LDS R24, 0x00
0422  280E     OR R0, R14
0423  6180     ORI R24, 0x10
0424  9380     STS 0x00, R24
0425  280E     OR R0, R14
285:           	DataPos=0;
0426  9210     STS 0x00, R1
0427  280F     OR R0, R15
0428  9210     STS 0x00, R1
0429  2810     OR R1, R0
286:           	#if PHYSICAL_TYPE == 485
287:           	transceiver_txen();
288:           	#endif
289:           	UART_CONTROL|=(1<<UART_UDRIE);
042A  E0E0     LDI R30, 0x00
042B  E0F8     LDI R31, 0x08
042C  8185     LDD R24, Z+5
042D  6280     ORI R24, 0x20
042E  8385     STD Z+5, R24
290:           	BusState&=~(1<<ReceiveCompleted);
042F  9180     LDS R24, 0x00
0430  280E     OR R0, R14
0431  7F87     ANDI R24, 0xF7
0432  9380     STS 0x00, R24
0433  280E     OR R0, R14
0434  9508     RET
291:           }
292:           
293:           /* @brief: Sends an exception response.
294:           *
295:           *         Arguments: - exceptionCode
296:           *                              
297:           */
298:           void modbusSendException(unsigned char exceptionCode)
299:           {
300:           	rxbuffer[1]|=(1<<7); //setting MSB of the function code (the exception flag)
0435  E4EF     LDI R30, 0x4F
0436  E2F8     LDI R31, 0x28
0437  8191     LDD R25, Z+1
0438  6890     ORI R25, 0x80
0439  8391     STD Z+1, R25
301:           	rxbuffer[2]=exceptionCode; //Exceptioncode. Also the last byte containing data
043A  8382     STD Z+2, R24
302:           	modbusSendMessage(2);
043B  E082     LDI R24, 0x02
043C  940E     CALL modbusGetAddress
043D  0418     CPC R1, R8
043E  9508     RET
303:           }
304:           
305:           
306:           /* @brief:  Returns the amount of requested data objects (coils, discretes, registers)
307:           *
308:           */
309:           uint16_t modbusRequestedAmount(void)
310:           {
311:           	return (rxbuffer[5]|(rxbuffer[4]<<8));
043F  E4EF     LDI R30, 0x4F
0440  E2F8     LDI R31, 0x28
0441  8185     LDD R24, Z+5
0442  8124     LDD R18, Z+4
0443  E090     LDI R25, 0x00
312:           }
0444  2B92     OR R25, R18
0445  9508     RET
313:           
314:           /* @brief: Returns the address of the first requested data object (coils, discretes, registers)
315:           *
316:           */
317:           uint16_t modbusRequestedAddress(void)
318:           {
319:           	return (rxbuffer[3]|(rxbuffer[2]<<8));
0446  E4EF     LDI R30, 0x4F
0447  E2F8     LDI R31, 0x28
0448  8183     LDD R24, Z+3
0449  8122     LDD R18, Z+2
044A  E090     LDI R25, 0x00
320:           }
044B  2B92     OR R25, R18
044C  9508     RET
321:           
322:           /* @brief: copies a single or multiple bytes from one array of bytes to an array of 16-bit-words
323:           *
324:           */
325:           void intToModbusRegister(volatile uint16_t *inreg, volatile uint8_t *outreg, uint8_t amount)
326:           {
327:           	for (uint8_t c=0; c<amount; c++)
044D  2344     AND R20, R20
044E  F081     BREQ 0x45F
044F  2FA8     MOV R26, R24
0450  2FB9     MOV R27, R25
0451  2FE6     MOV R30, R22
0452  2FF7     MOV R31, R23
0453  E080     LDI R24, 0x00
045B  5F8F     SUBI R24, 0xFF
045C  9632     ADIW R30, 0x02
045D  1348     CPSE R20, R24
045E  CFF5     RJMP 0x454
045F  9508     RET
328:           	{
329:           			*(outreg+c*2) = (uint8_t)(*(inreg+c) >> 8);
0454  912D     LD R18, X+
0455  913C     LD R19, X
0456  9711     SBIW R26, 0x01
0457  8330     ST Z, R19
330:           			*(outreg+1+c*2) = (uint8_t)(*(inreg+c));
0458  912D     LD R18, X+
0459  913D     LD R19, X+
045A  8321     STD Z+1, R18
045B  5F8F     SUBI R24, 0xFF
045C  9632     ADIW R30, 0x02
045D  1348     CPSE R20, R24
045E  CFF5     RJMP 0x454
045F  9508     RET
331:           	}
332:           }
333:           
334:           /* @brief: copies a single or multiple 16-bit-words from one array of integers to an array of bytes
335:           *
336:           */
337:           void modbusRegisterToInt(volatile uint8_t *inreg, volatile uint16_t *outreg, uint8_t amount)
338:           {
339:           	for (uint8_t c=0; c<amount; c++)
0460  2344     AND R20, R20
0461  F091     BREQ 0x474
0462  2FE8     MOV R30, R24
0463  2FF9     MOV R31, R25
0464  2FA6     MOV R26, R22
0465  2FB7     MOV R27, R23
0466  E020     LDI R18, 0x00
0470  5F2F     SUBI R18, 0xFF
0471  9632     ADIW R30, 0x02
0472  1342     CPSE R20, R18
0473  CFF3     RJMP 0x467
0474  9508     RET
340:           	{
341:           		*(outreg+c) = (*(inreg+c*2) << 8) + *(inreg+1+c*2);
0467  8180     LD R24, Z
0468  8131     LDD R19, Z+1
0469  E090     LDI R25, 0x00
046A  2F98     MOV R25, R24
046B  2788     EOR R24, R24
046C  0F83     ADD R24, R19
046D  1D91     ADC R25, R1
046E  938D     ST X+, R24
046F  939D     ST X+, R25
0470  5F2F     SUBI R18, 0xFF
0471  9632     ADIW R30, 0x02
0472  1342     CPSE R20, R18
0473  CFF3     RJMP 0x467
0474  9508     RET
342:           	}
343:           }
344:           
345:           /* @brief: Handles single/multiple register reading and single/multiple register writing.
346:           *
347:           *         Arguments: - ptrToInArray: pointer to the user's data array containing registers
348:           *                    - startAddress: address of the first register in the supplied array
349:           *                    - size: input array size in the requested format (16bit-registers)
350:           *
351:           */
352:           uint8_t modbusExchangeRegisters(volatile uint16_t *ptrToInArray, uint16_t startAddress, uint16_t size)
353:           {
0475  92CF     PUSH R12
0476  92DF     PUSH R13
0477  92EF     PUSH R14
0478  92FF     PUSH R15
0479  930F     PUSH R16
047A  931F     PUSH R17
047B  93CF     PUSH R28
047C  93DF     PUSH R29
047D  016C     MOVW R12, R24
047E  018B     MOVW R16, R22
047F  01EA     MOVW R28, R20
354:           	uint16_t requestedAmount = modbusRequestedAmount();
0480  940E     CALL modbusGetAddress
355:           	uint16_t requestedAdr = modbusRequestedAddress();
0483  940E     CALL modbusGetAddress
0484  0446     CPC R4, R6
356:           	if (rxbuffer[1]==fcPresetSingleRegister) requestedAmount=1;
0485  9120     LDS R18, 0x00
0486  2850     OR R5, R0
0487  3026     CPI R18, 0x06
0488  F419     BRNE 0x48C
0489  24EE     EOR R14, R14
048A  94E3     INC R14
048B  2CF1     MOV R15, R1
357:           	if ((requestedAdr>=startAddress) && ((startAddress+size)>=(requestedAmount+requestedAdr))) {
048C  1780     CP R24, R16
0490  0FC0     ADD R28, R16
0491  1FD1     ADC R29, R17
0492  0197     MOVW R18, R14
0493  0F28     ADD R18, R24
0494  1F39     ADC R19, R25
0495  17C2     CP R28, R18
0496  07D3     CPC R29, R19
0497  F408     BRCC 0x499
0498  C06D     RJMP 0x506
358:           		
359:           		if ((rxbuffer[1]==fcReadHoldingRegisters) || (rxbuffer[1]==fcReadInputRegisters) )
0499  9120     LDS R18, 0x00
049A  2850     OR R5, R0
049B  3023     CPI R18, 0x03
049C  F021     BREQ 0x4A1
049D  9120     LDS R18, 0x00
049E  2850     OR R5, R0
049F  3024     CPI R18, 0x04
04A0  F509     BRNE 0x4C2
360:           		{
361:           			if ((requestedAmount*2)<=(MaxFrameIndex-4)) //message buffer big enough?
04A1  0197     MOVW R18, R14
04A2  0F22     ADD R18, R18
04A3  1F33     ADC R19, R19
04A4  3F2C     CPI R18, 0xFC
04A5  0531     CPC R19, R1
04A6  F4B0     BRCC 0x4BD
04C1  C04A     RJMP 0x50C
362:           			{
363:           				rxbuffer[2]=(unsigned char)(requestedAmount*2);
04A7  2D9E     MOV R25, R14
04A8  0F99     ADD R25, R25
04A9  E4CF     LDI R28, 0x4F
04AA  E2D8     LDI R29, 0x28
04AB  839A     STD Y+2, R25
364:           				intToModbusRegister(ptrToInArray+(unsigned char)(requestedAdr-startAddress),rxbuffer+3,requestedAmount);
04AC  1B80     SUB R24, R16
04AD  E090     LDI R25, 0x00
04AE  0F88     ADD R24, R24
04AF  1F99     ADC R25, R25
04B0  2D4E     MOV R20, R14
04B1  E562     LDI R22, 0x52
04B2  E278     LDI R23, 0x28
04B3  0D8C     ADD R24, R12
04B4  1D9D     ADC R25, R13
04B5  940E     CALL modbusGetAddress
04B6  044D     CPC R4, R13
365:           				modbusSendMessage(2+rxbuffer[2]);
04B7  818A     LDD R24, Y+2
04B8  5F8E     SUBI R24, 0xFE
04B9  940E     CALL modbusGetAddress
04BA  0418     CPC R1, R8
366:           				return 1;
04BB  E081     LDI R24, 0x01
04BC  C04F     RJMP 0x50C
367:           			} else modbusSendException(ecIllegalDataValue);
04BD  E083     LDI R24, 0x03
04BE  940E     CALL modbusGetAddress
04BF  0435     CPC R3, R5
368:           		}
369:           		else if (rxbuffer[1]==fcPresetMultipleRegisters)
04C2  9120     LDS R18, 0x00
04C3  2850     OR R5, R0
04C4  3120     CPI R18, 0x10
04C5  F559     BRNE 0x4F1
370:           		{
371:           			if (((rxbuffer[6])>=requestedAmount*2) && ((DataPos-9)>=rxbuffer[6])) //enough data received?
04C6  9120     LDS R18, 0x00
04C7  2855     OR R5, R5
04C8  E030     LDI R19, 0x00
04C9  01A7     MOVW R20, R14
04CA  0F44     ADD R20, R20
04CB  1F55     ADC R21, R21
04CC  1724     CP R18, R20
04CD  0735     CPC R19, R21
04CE  F0E8     BRCS 0x4EC
04CF  9140     LDS R20, 0x00
04D0  280F     OR R0, R15
04D1  9150     LDS R21, 0x00
04D2  2810     OR R1, R0
04D3  9120     LDS R18, 0x00
04D4  2855     OR R5, R5
04D5  5049     SUBI R20, 0x09
04D6  0951     SBC R21, R1
04D7  E030     LDI R19, 0x00
04D8  1742     CP R20, R18
04D9  0753     CPC R21, R19
04DA  F088     BRCS 0x4EC
372:           			{
373:           				modbusRegisterToInt(rxbuffer+7,ptrToInArray+(unsigned char)(requestedAdr-startAddress),(unsigned char)(requestedAmount));
04DB  1B80     SUB R24, R16
04DC  2F68     MOV R22, R24
04DD  E070     LDI R23, 0x00
04DE  0F66     ADD R22, R22
04DF  1F77     ADC R23, R23
04E0  0D6C     ADD R22, R12
04E1  1D7D     ADC R23, R13
04E2  2D4E     MOV R20, R14
04E3  E586     LDI R24, 0x56
04E4  E298     LDI R25, 0x28
04E5  940E     CALL modbusGetAddress
04E6  0460     CPC R6, R0
374:           				modbusSendMessage(5);
04E7  E085     LDI R24, 0x05
04E8  940E     CALL modbusGetAddress
04E9  0418     CPC R1, R8
375:           				return 1;
04EA  E081     LDI R24, 0x01
04EB  C020     RJMP 0x50C
376:           			} else modbusSendException(ecIllegalDataValue);//too few data bytes received
04EC  E083     LDI R24, 0x03
04ED  940E     CALL modbusGetAddress
04EE  0435     CPC R3, R5
377:           		}
378:           		else if (rxbuffer[1]==fcPresetSingleRegister)
04F1  9120     LDS R18, 0x00
04F2  2850     OR R5, R0
04F3  3026     CPI R18, 0x06
04F4  F4B1     BRNE 0x50B
379:           		{
380:           			modbusRegisterToInt(rxbuffer+4,ptrToInArray+(unsigned char)(requestedAdr-startAddress),1);
04F5  1B80     SUB R24, R16
04F6  2F68     MOV R22, R24
04F7  E070     LDI R23, 0x00
04F8  0F66     ADD R22, R22
04F9  1F77     ADC R23, R23
04FA  0D6C     ADD R22, R12
04FB  1D7D     ADC R23, R13
04FC  E041     LDI R20, 0x01
04FD  E583     LDI R24, 0x53
04FE  E298     LDI R25, 0x28
04FF  940E     CALL modbusGetAddress
0500  0460     CPC R6, R0
381:           			modbusSendMessage(5);
0501  E085     LDI R24, 0x05
0502  940E     CALL modbusGetAddress
0503  0418     CPC R1, R8
382:           			return 1;
0504  E081     LDI R24, 0x01
0505  C006     RJMP 0x50C
383:           		} 
384:           		//modbusSendException(ecSlaveDeviceFailure); //inapropriate call of modbusExchangeRegisters
385:           		return 0;
04C0  E080     LDI R24, 0x00
04EF  E080     LDI R24, 0x00
04F0  C01B     RJMP 0x50C
050B  E080     LDI R24, 0x00
386:           		} else {
387:           		modbusSendException(ecIllegalDataValue);
0506  E083     LDI R24, 0x03
0507  940E     CALL modbusGetAddress
0508  0435     CPC R3, R5
388:           		return 0;
0509  E080     LDI R24, 0x00
050A  C001     RJMP 0x50C
389:           	}
390:           }
050C  91DF     POP R29
050D  91CF     POP R28
050E  911F     POP R17
050F  910F     POP R16
0510  90FF     POP R15
0511  90EF     POP R14
0512  90DF     POP R13
0513  90CF     POP R12
0514  9508     RET
391:           
392:           /* @brief: Handles single/multiple input/coil reading and single/multiple coil writing.
393:           *
394:           *         Arguments: - ptrToInArray: pointer to the user's data array containing bits
395:           *                    - startAddress: address of the first bit in the supplied array
396:           *                    - size: input array size in the requested format (bits)
397:           *
398:           */
399:           uint8_t modbusExchangeBits(volatile uint8_t *ptrToInArray, uint16_t startAddress, uint16_t size)
400:           {
0515  92CF     PUSH R12
0516  92DF     PUSH R13
0517  92EF     PUSH R14
0518  92FF     PUSH R15
0519  930F     PUSH R16
051A  931F     PUSH R17
051B  93CF     PUSH R28
051C  93DF     PUSH R29
051D  016C     MOVW R12, R24
051E  017B     MOVW R14, R22
051F  01EA     MOVW R28, R20
401:           	uint16_t requestedAmount = modbusRequestedAmount();
0520  940E     CALL modbusGetAddress
0521  043F     CPC R3, R15
0522  018C     MOVW R16, R24
402:           	uint16_t requestedAdr = modbusRequestedAddress();
0523  940E     CALL modbusGetAddress
0524  0446     CPC R4, R6
403:           	if (rxbuffer[1]==fcForceSingleCoil) requestedAmount=1;
0525  9120     LDS R18, 0x00
0526  2850     OR R5, R0
0527  3025     CPI R18, 0x05
0528  F411     BRNE 0x52B
0529  E001     LDI R16, 0x01
052A  E010     LDI R17, 0x00
404:           	if ((requestedAdr>=startAddress) && ((startAddress+size)>=(requestedAmount+requestedAdr)))
052B  158E     CP R24, R14
052C  059F     CPC R25, R15
052D  F408     BRCC 0x52F
052E  C0A2     RJMP 0x5D1
052F  0DCE     ADD R28, R14
0530  1DDF     ADC R29, R15
0531  0198     MOVW R18, R16
0532  0F28     ADD R18, R24
0533  1F39     ADC R19, R25
0534  17C2     CP R28, R18
0535  07D3     CPC R29, R19
0536  F408     BRCC 0x538
0537  C099     RJMP 0x5D1
405:           	{
406:           		if ((rxbuffer[1]==fcReadInputStatus) || (rxbuffer[1]==fcReadCoilStatus))
0538  9120     LDS R18, 0x00
0539  2850     OR R5, R0
053A  3022     CPI R18, 0x02
053B  F029     BREQ 0x541
053C  9120     LDS R18, 0x00
053D  2850     OR R5, R0
053E  3021     CPI R18, 0x01
053F  F009     BREQ 0x541
0540  C041     RJMP 0x582
407:           		{
408:           			if (requestedAmount<=((MaxFrameIndex-4)*8)) //message buffer big enough?
0541  3D09     CPI R16, 0xD9
0542  E027     LDI R18, 0x07
0543  0712     CPC R17, R18
0544  F5C0     BRCC 0x57D
0581  C055     RJMP 0x5D7
409:           			{
410:           				rxbuffer[2]=(requestedAmount/8);
0545  0198     MOVW R18, R16
0546  9536     LSR R19
0547  9527     ROR R18
0548  9536     LSR R19
0549  9527     ROR R18
054A  9536     LSR R19
054B  9527     ROR R18
054C  9320     STS 0x00, R18
054D  2851     OR R5, R1
411:           				if (requestedAmount%8>0)
054E  01A8     MOVW R20, R16
054F  7047     ANDI R20, 0x07
0550  2755     EOR R21, R21
0551  2B45     OR R20, R21
0552  F069     BREQ 0x560
412:           				{
413:           					rxbuffer[(uint8_t)(requestedAmount/8)+3]=0x00; //fill last data byte with zeros
0553  2733     EOR R19, R19
0554  E4AF     LDI R26, 0x4F
0555  E2B8     LDI R27, 0x28
0556  01F9     MOVW R30, R18
0557  5AEE     SUBI R30, 0xAE
0558  4DF7     SBCI R31, 0xD7
0559  8210     ST Z, R1
414:           					rxbuffer[2]++;
055A  9612     ADIW R26, 0x02
055B  912C     LD R18, X
055C  9712     SBIW R26, 0x02
055D  5F2F     SUBI R18, 0xFF
055E  9612     ADIW R26, 0x02
055F  932C     ST X, R18
415:           				}
416:           				for (uint16_t c = 0; c<requestedAmount; c++)
0560  1501     CP R16, R1
0561  0511     CPC R17, R1
0562  F099     BREQ 0x576
0563  E0C0     LDI R28, 0x00
0564  E0D0     LDI R29, 0x00
0572  9621     ADIW R28, 0x01
0573  170C     CP R16, R28
0574  071D     CPC R17, R29
0575  F799     BRNE 0x569
417:           				{
418:           					listBitCopy(ptrToInArray,requestedAdr-startAddress+c,rxbuffer+3,c);
0565  019C     MOVW R18, R24
0566  192E     SUB R18, R14
0567  093F     SBC R19, R15
0568  0179     MOVW R14, R18
0569  01B7     MOVW R22, R14
056A  0F6C     ADD R22, R28
056B  1F7D     ADC R23, R29
056C  019E     MOVW R18, R28
056D  E542     LDI R20, 0x52
056E  E258     LDI R21, 0x28
056F  01C6     MOVW R24, R12
0570  940E     CALL modbusGetAddress
0571  0295     MULS R25, R21
419:           				}
420:           				modbusSendMessage(rxbuffer[2]+2);
0576  9180     LDS R24, 0x00
0577  2851     OR R5, R1
0578  5F8E     SUBI R24, 0xFE
0579  940E     CALL modbusGetAddress
057A  0418     CPC R1, R8
421:           				return 1;
057B  E081     LDI R24, 0x01
057C  C05A     RJMP 0x5D7
422:           			} else modbusSendException(ecIllegalDataValue); //too many bits requested within single request
057D  E083     LDI R24, 0x03
057E  940E     CALL modbusGetAddress
057F  0435     CPC R3, R5
423:           		}
424:           		else if (rxbuffer[1]==fcForceMultipleCoils)
0582  9120     LDS R18, 0x00
0583  2850     OR R5, R0
0584  302F     CPI R18, 0x0F
0585  F5C1     BRNE 0x5BE
425:           		{
426:           			if (((rxbuffer[6]*8)>=requestedAmount) && ((DataPos-9)>=rxbuffer[6])) //enough data received?
0586  9120     LDS R18, 0x00
0587  2855     OR R5, R5
0588  E030     LDI R19, 0x00
0589  0F22     ADD R18, R18
058A  1F33     ADC R19, R19
058B  0F22     ADD R18, R18
058C  1F33     ADC R19, R19
058D  0F22     ADD R18, R18
058E  1F33     ADC R19, R19
058F  1720     CP R18, R16
0590  0731     CPC R19, R17
0591  F138     BRCS 0x5B9
0592  9140     LDS R20, 0x00
0593  280F     OR R0, R15
0594  9150     LDS R21, 0x00
0595  2810     OR R1, R0
0596  9120     LDS R18, 0x00
0597  2855     OR R5, R5
0598  5049     SUBI R20, 0x09
0599  0951     SBC R21, R1
059A  E030     LDI R19, 0x00
059B  1742     CP R20, R18
059C  0753     CPC R21, R19
059D  F0D8     BRCS 0x5B9
427:           			{
428:           				for (uint16_t c = 0; c<requestedAmount; c++)
059E  1501     CP R16, R1
059F  0511     CPC R17, R1
05A0  F099     BREQ 0x5B4
05A1  E0C0     LDI R28, 0x00
05A2  E0D0     LDI R29, 0x00
05B0  9621     ADIW R28, 0x01
05B1  170C     CP R16, R28
05B2  071D     CPC R17, R29
05B3  F799     BRNE 0x5A7
429:           				{
430:           					listBitCopy(rxbuffer+7,c,ptrToInArray,requestedAdr-startAddress+c);
05A3  019C     MOVW R18, R24
05A4  192E     SUB R18, R14
05A5  093F     SBC R19, R15
05A6  0179     MOVW R14, R18
05A7  0197     MOVW R18, R14
05A8  0F2C     ADD R18, R28
05A9  1F3D     ADC R19, R29
05AA  01A6     MOVW R20, R12
05AB  01BE     MOVW R22, R28
05AC  E586     LDI R24, 0x56
05AD  E298     LDI R25, 0x28
05AE  940E     CALL modbusGetAddress
05AF  0295     MULS R25, R21
431:           				}
432:           				modbusSendMessage(5);
05B4  E085     LDI R24, 0x05
05B5  940E     CALL modbusGetAddress
05B6  0418     CPC R1, R8
433:           				return 1;
05B7  E081     LDI R24, 0x01
05B8  C01E     RJMP 0x5D7
434:           			} else modbusSendException(ecIllegalDataValue);//exception too few data bytes received
05B9  E083     LDI R24, 0x03
05BA  940E     CALL modbusGetAddress
05BB  0435     CPC R3, R5
435:           		}
436:           		else if (rxbuffer[1]==fcForceSingleCoil) {
05BE  9120     LDS R18, 0x00
05BF  2850     OR R5, R0
05C0  3025     CPI R18, 0x05
05C1  F4A1     BRNE 0x5D6
437:           			listBitCopy(rxbuffer+4,0,ptrToInArray,requestedAdr-startAddress);
05C2  019C     MOVW R18, R24
05C3  192E     SUB R18, R14
05C4  093F     SBC R19, R15
05C5  01A6     MOVW R20, R12
05C6  E060     LDI R22, 0x00
05C7  E070     LDI R23, 0x00
05C8  E583     LDI R24, 0x53
05C9  E298     LDI R25, 0x28
05CA  940E     CALL modbusGetAddress
05CB  0295     MULS R25, R21
438:           			modbusSendMessage(5); 
05CC  E085     LDI R24, 0x05
05CD  940E     CALL modbusGetAddress
05CE  0418     CPC R1, R8
439:           			return 1;
05CF  E081     LDI R24, 0x01
05D0  C006     RJMP 0x5D7
440:           		}
441:           		//modbusSendException(ecSlaveDeviceFailure); //inanpropriate call of modbusExchangeBits
442:           		return 0;
0580  E080     LDI R24, 0x00
05BC  E080     LDI R24, 0x00
05D6  E080     LDI R24, 0x00
443:           	} else
444:           	{
445:           		modbusSendException(ecIllegalDataValue);
05D1  E083     LDI R24, 0x03
05D2  940E     CALL modbusGetAddress
05D3  0435     CPC R3, R5
446:           		return 0;
05D4  E080     LDI R24, 0x00
05D5  C001     RJMP 0x5D7
447:           	}
448:           }
05D7  91DF     POP R29
05D8  91CF     POP R28
05D9  911F     POP R17
05DA  910F     POP R16
05DB  90FF     POP R15
05DC  90EF     POP R14
05DD  90DF     POP R13
05DE  90CF     POP R12
05DF  9508     RET
---  /home/sasquachdm/Dropbox/DJMHardware/trailer-automation/battery-inverter/code/inverter_serial/modbus.c
1:             /*
2:              *  Created: 04.02.2016
3:              *  Author: Max Brueggemann
4:              */ 
5:             
6:             /*
7:             *	An example project implementing a simple modbus slave device using an
8:             *	ATmega88PA running at 20MHz.
9:             *	Baudrate: 38400, 8 data bits, 1 stop bit, no parity
10:            *	Your busmaster can read/write the following data:
11:            *	coils: 0 to 7
12:            *	discrete inputs: 0 to 7
13:            *	input registers: 0 to 3
14:            *	holding registers: 0 to 3
15:            */
16:            
17:            #define clientAddress 0x01
18:            
19:            #include <avr/io.h>
20:            #include <avr/interrupt.h>
21:            #include <avr/wdt.h>
22:            #include "modbus.h"
23:            #include "yaMBSiavr.h"
24:            
25:            volatile uint8_t instate = 0;
26:            volatile uint8_t outstate = 0;
27:            volatile uint8_t ins = 0;
28:            volatile uint8_t outs = 0;
29:            volatile uint16_t inputRegisters[4];
30:            volatile uint16_t holdingRegisters[4];
31:            
32:            /*
33:            *   Modify the following 3 functions to implement your own pin configurations...
34:            */
35:            
36:            /*
37:            void SetOuts(volatile uint8_t in) {
38:            	PORTD|= (((in & (1<<3))<<4) | ((in & (1<<4))<<1) | ((in & (1<<5))<<1));
39:            	PORTB|= (((in & (1<<0))<<2) | ((in & (1<<1))) | ((in & (1<<2))>>2));
40:            	in=~in;
41:            	PORTB&= ~(((in & (1<<0))<<2) | ((in & (1<<1))) | ((in & (1<<2))>>2));
42:            	PORTD&= ~(((in & (1<<3))<<4) | ((in & (1<<4))<<1) | ((in & (1<<5))<<1));
43:            }
44:            
45:            uint8_t ReadIns(void) {
46:            	uint8_t ins=0x00;
47:            	ins|=(PINC&((1<<0)|(1<<1)|(1<<2)|(1<<3)|(1<<4)|(1<<5)));
48:            	ins|=(((PIND&(1<<4))<<2)|((PIND&(1<<3))<<4));
49:            	return ins;
50:            }
51:            
52:            void io_conf(void) { 
53:            	/*
54:            	 Outputs: PB2,PB1,PB0,PD7,PD5,PD6
55:            	 Inputs: PC0, PC1, PC2, PC3, PC4, PC6, PD4, PD3
56:            	*/
57:            /*
58:                DDRD=0x00;
59:            	DDRB=0x00;
60:            	DDRC=0x00;
61:            	PORTD=0x00;
62:            	PORTB=0x00;
63:            	PORTC=0x00;
64:            	PORTD|=(1<<0);
65:            	DDRD |= (1<<2)|(1<<5)|(1<<6)|(1<<7);
66:            	DDRB |= (1<<0)|(1<<1)|(1<<2)|(1<<3);
67:            }
68:            */
69:            
70:            void modbus_get(void) {
71:            	if (modbusGetBusState() & (1<<ReceiveCompleted))
01E2  940E     CALL modbusGetAddress
01E3  0249     MULS R20, R25
01E4  FF83     SBRS R24, 3
01E5  C059     RJMP 0x23F
72:            	{
73:            		switch(rxbuffer[1]) {
01E6  91E0     LDS R30, 0x00
01E7  2850     OR R5, R0
01E8  2F8E     MOV R24, R30
01E9  E090     LDI R25, 0x00
01EA  01FC     MOVW R30, R24
01EB  9731     SBIW R30, 0x01
01EC  31E0     CPI R30, 0x10
01ED  05F1     CPC R31, R1
01EE  F008     BRCS 0x1F0
01EF  C04C     RJMP 0x23C
01F0  5BE0     SUBI R30, 0xB0
01F1  4FFF     SBCI R31, 0xFF
01F2  940C     JMP modbusGetAddress
01F3  05E0     CPC R30, R0
74:            			case fcReadCoilStatus: {
75:            				modbusExchangeBits(&outstate,0,8);
01F4  E048     LDI R20, 0x08
01F5  E050     LDI R21, 0x00
01F6  E060     LDI R22, 0x00
01F7  E070     LDI R23, 0x00
01F8  E08A     LDI R24, 0x0A
01F9  E298     LDI R25, 0x28
01FA  940E     CALL modbusGetAddress
01FB  0515     CPC R17, R5
76:            			}
77:            			break;
01FC  9508     RET
78:            			
79:            			case fcReadInputStatus: {
80:            				//volatile uint8_t inps = ReadIns();
81:            				modbusExchangeBits(&ins,0,8);
01FD  E048     LDI R20, 0x08
01FE  E050     LDI R21, 0x00
01FF  E060     LDI R22, 0x00
0200  E070     LDI R23, 0x00
0201  E089     LDI R24, 0x09
0202  E298     LDI R25, 0x28
0203  940E     CALL modbusGetAddress
0204  0515     CPC R17, R5
82:            			}
83:            			break;
0205  9508     RET
84:            			
85:            			case fcReadHoldingRegisters: {
86:            				modbusExchangeRegisters(holdingRegisters,0,4);
0206  E044     LDI R20, 0x04
0207  E050     LDI R21, 0x00
0208  E060     LDI R22, 0x00
0209  E070     LDI R23, 0x00
020A  E38F     LDI R24, 0x3F
020B  E298     LDI R25, 0x28
020C  940E     CALL modbusGetAddress
020D  0475     CPC R7, R5
87:            			}
88:            			break;
020E  9508     RET
89:            			
90:            			case fcReadInputRegisters: {
91:            				modbusExchangeRegisters(inputRegisters,0,4);
020F  E044     LDI R20, 0x04
0210  E050     LDI R21, 0x00
0211  E060     LDI R22, 0x00
0212  E070     LDI R23, 0x00
0213  E487     LDI R24, 0x47
0214  E298     LDI R25, 0x28
0215  940E     CALL modbusGetAddress
0216  0475     CPC R7, R5
92:            			}
93:            			break;
0217  9508     RET
94:            			
95:            			case fcForceSingleCoil: {
96:            				modbusExchangeBits(&outstate,0,8);
0218  E048     LDI R20, 0x08
0219  E050     LDI R21, 0x00
021A  E060     LDI R22, 0x00
021B  E070     LDI R23, 0x00
021C  E08A     LDI R24, 0x0A
021D  E298     LDI R25, 0x28
021E  940E     CALL modbusGetAddress
021F  0515     CPC R17, R5
97:            				//SetOuts(outstate);
98:            			}
99:            			break;
0220  9508     RET
100:           			
101:           			case fcPresetSingleRegister: {
102:           				modbusExchangeRegisters(holdingRegisters,0,4);
0221  E044     LDI R20, 0x04
0222  E050     LDI R21, 0x00
0223  E060     LDI R22, 0x00
0224  E070     LDI R23, 0x00
0225  E38F     LDI R24, 0x3F
0226  E298     LDI R25, 0x28
0227  940E     CALL modbusGetAddress
0228  0475     CPC R7, R5
103:           			}
104:           			break;
0229  9508     RET
105:           			
106:           			case fcForceMultipleCoils: {
107:           				modbusExchangeBits(&outstate,0,8);
022A  E048     LDI R20, 0x08
022B  E050     LDI R21, 0x00
022C  E060     LDI R22, 0x00
022D  E070     LDI R23, 0x00
022E  E08A     LDI R24, 0x0A
022F  E298     LDI R25, 0x28
0230  940E     CALL modbusGetAddress
0231  0515     CPC R17, R5
108:           				//SetOuts(outstate);
109:           			}
110:           			break;
0232  9508     RET
111:           			
112:           			case fcPresetMultipleRegisters: {
113:           				modbusExchangeRegisters(holdingRegisters,0,4);
0233  E044     LDI R20, 0x04
0234  E050     LDI R21, 0x00
0235  E060     LDI R22, 0x00
0236  E070     LDI R23, 0x00
0237  E38F     LDI R24, 0x3F
0238  E298     LDI R25, 0x28
0239  940E     CALL modbusGetAddress
023A  0475     CPC R7, R5
114:           			}
115:           			break;
023B  9508     RET
116:           			
117:           			default: {
118:           				modbusSendException(ecIllegalFunction);
023C  E081     LDI R24, 0x01
023D  940E     CALL modbusGetAddress
023E  0435     CPC R3, R5
023F  9508     RET
119:           			}
120:           			break;
121:           		}
122:           	}
123:           }
124:           
125:           void modbus_init(void)
126:           {
127:           	//io_conf();
128:           	modbusSetAddress(clientAddress);
0240  E081     LDI R24, 0x01
0241  940E     CALL modbusGetAddress
0242  024C     MULS R20, R28
129:           	modbusInit();
0243  940E     CALL modbusGetAddress
0244  0404     CPC R0, R4
0245  9508     RET
130:           }
131:           
132:           void modbus_tick(void)
133:           {
134:           	    modbusTickTimer();
0246  940E     CALL modbusGetAddress
0247  02DE     MULS R29, R30
0248  9508     RET
135:           }
136:           
---  /home/sasquachdm/Dropbox/DJMHardware/trailer-automation/battery-inverter/code/inverter_serial/main.c
1:             /* 
2:              * File:   main.c
3:              * Author: sasquachdm
4:              *
5:              * Created on March 10, 2020, 10:40 PM
6:              */
7:             
8:             
9:             #include <avr/io.h>
10:            #include "hardware.h"
11:            #include <avr/interrupt.h>
12:            #include <util/delay.h>
13:            #include "modbus.h"
14:            #include "inverter.h"
15:            
16:            volatile uint8_t tickcount=0;
17:            
18:            ISR(TCB0_INT_vect) { //this ISR is called 5000 times per second
007F  921F     PUSH R1
0080  920F     PUSH R0
0081  B60F     IN R0, 0x3F
0082  920F     PUSH R0
0083  2411     EOR R1, R1
0084  932F     PUSH R18
0085  933F     PUSH R19
0086  934F     PUSH R20
0087  935F     PUSH R21
0088  936F     PUSH R22
0089  937F     PUSH R23
008A  938F     PUSH R24
008B  939F     PUSH R25
008C  93AF     PUSH R26
008D  93BF     PUSH R27
008E  93EF     PUSH R30
008F  93FF     PUSH R31
19:                TCB0.INTFLAGS = 1 << TCB_CAPT_bp;
0090  E081     LDI R24, 0x01
0091  9380     STS 0x00, R24
0092  0A86     SBC R8, R22
20:            	modbus_tick();
0093  940E     CALL modbusGetAddress
0094  0246     MULS R20, R22
21:                tickcount++;
0095  9180     LDS R24, 0x00
0096  2802     OR R0, R2
0097  5F8F     SUBI R24, 0xFF
0098  9380     STS 0x00, R24
0099  2802     OR R0, R2
22:                if (tickcount >= 5) {
009A  9180     LDS R24, 0x00
009B  2802     OR R0, R2
009C  3085     CPI R24, 0x05
009D  F020     BRCS 0xA2
23:                    tickcount = 0;
009E  9210     STS 0x00, R1
009F  2802     OR R0, R2
24:                    INVERTER_tick();
00A0  940E     CALL modbusGetAddress
00A1  01BA     MOVW R22, R20
25:                }
26:                
27:            }
00A2  91FF     POP R31
00A3  91EF     POP R30
00A4  91BF     POP R27
00A5  91AF     POP R26
00A6  919F     POP R25
00A7  918F     POP R24
00A8  917F     POP R23
00A9  916F     POP R22
00AA  915F     POP R21
00AB  914F     POP R20
00AC  913F     POP R19
00AD  912F     POP R18
00AE  900F     POP R0
00AF  BE0F     OUT 0x3F, R0
00B0  900F     POP R0
00B1  901F     POP R1
00B2  9518     RETI
28:            void tick_interupt_init(void){
29:                TCB0.CCMP = F_CPU / 5000;
00B3  E8E0     LDI R30, 0x80
00B4  E0FA     LDI R31, 0x0A
00B5  ED80     LDI R24, 0xD0
00B6  E097     LDI R25, 0x07
00B7  8784     STD Z+12, R24
00B8  8795     STD Z+13, R25
30:                TCB0.INTCTRL = 1 << TCB_CAPT_bp;
00B9  E081     LDI R24, 0x01
00BA  8385     STD Z+5, R24
31:                TCB0.CTRLB = TCB_CNTMODE_INT_gc;
00BB  8211     STD Z+1, R1
32:                TCB0.CTRLA = TCB_CLKSEL_CLKDIV1_gc | 1<< TCB_ENABLE_bp;
00BC  8380     ST Z, R24
00BD  9508     RET
33:            }
34:            
35:            int main(void)
36:            {
37:                _PROTECTED_WRITE(CLKCTRL.MCLKCTRLB, CLKCTRL_PDIV_2X_gc | CLKCTRL_PEN_bm);
00BE  E021     LDI R18, 0x01
00BF  E030     LDI R19, 0x00
00C0  ED88     LDI R24, 0xD8
00C1  BF84     OUT 0x34, R24
00C2  9320     STS 0x00, R18
38:                //USART0_init();
39:                TCB1.CCMP = 0xffff;
00C4  E9E0     LDI R30, 0x90
00C5  E0FA     LDI R31, 0x0A
00C6  EF8F     LDI R24, 0xFF
00C7  EF9F     LDI R25, 0xFF
00C8  8784     STD Z+12, R24
00C9  8795     STD Z+13, R25
40:                // TCB1.INTCTRL = 1 << TCB_CAPT_bp;
41:                TCB1.CTRLB = TCB_CNTMODE_INT_gc;
00CA  8211     STD Z+1, R1
42:                TCB1.CTRLA = TCB_CLKSEL_CLKDIV1_gc | 1<< TCB_ENABLE_bp;
00CB  E081     LDI R24, 0x01
00CC  8380     ST Z, R24
43:                cli();
00CD  94F8     CLI
44:                modbus_init();
00CE  940E     CALL modbusGetAddress
00CF  0240     MULS R20, R16
45:                tick_interupt_init();
00D0  940E     CALL modbusGetAddress
46:                INVERTER_init();
00D2  940E     CALL modbusGetAddress
00D3  01B5     MOVW R22, R10
47:                sei();
00D4  9478     SEI
48:                while (1) 
49:                {
50:                    //USART0_sendString("Hello World!\r\n");
51:                    modbus_get();
00D5  940E     CALL modbusGetAddress
00D6  01E2     MOVW R28, R4
00D7  CFFD     RJMP 0xD5
52:                //    _delay_ms(500);
53:                }
54:            }
55:            
56:            
57:            /*
58:            void USART0_init(void);
59:            void USART0_sendChar(char c);
60:            void USART0_sendString(char *str);
61:            
62:            #define USART0_BAUD_RATE(BAUD_RATE) ((float)(F_CPU * 64 / (16 * (float)BAUD_RATE)) + 0.5)
63:            
64:            void USART0_init(void)
65:            {
66:                PORTA.DIR &= ~PIN1_bm;
67:                PORTA.DIR |= PIN0_bm;
68:                
69:                USART0.BAUD = (uint16_t)USART0_BAUD_RATE(9600);
70:            
71:                USART0.CTRLB |= USART_TXEN_bm; 
72:            }
73:            
74:            void USART0_sendChar(char c)
75:            {
76:                while (!(USART0.STATUS & USART_DREIF_bm))
77:                {
78:                    ;
79:                }        
80:                USART0.TXDATAL = c;
81:            }
82:            
83:            void USART0_sendString(char *str)
84:            {
85:                for(size_t i = 0; i < strlen(str); i++)
86:                {
87:                    USART0_sendChar(str[i]);
88:                }
89:            }
90:            
91:            */
---  /home/sasquachdm/Dropbox/DJMHardware/trailer-automation/battery-inverter/code/inverter_serial/inverter.c
1:             #include <avr/io.h>
2:             #include <util/delay.h>
3:             #include <string.h>
4:             #include <avr/interrupt.h>
5:             #include "inverter.h"
6:             
7:             volatile uint16_t Inverter_last_bytetime;
8:             volatile uint16_t Inverter_Tick_count=0;
9:             volatile uint8_t Inverter_Com_count=0;
10:            volatile uint8_t Inverter_TX_index=0;
11:            volatile uint8_t Inverter_RX_index=0;
12:            volatile uint8_t Inverter_TX[22];
13:            volatile uint8_t Inverter_RX[21];
14:            volatile uint8_t Inverter_RX_Error;
15:            volatile inverter_com_stat_t Inverter_Com_stat = RXStandby;
16:            
17:            ISR(RTC_CNT_vect)
18:            {
00D8  921F     PUSH R1
00D9  920F     PUSH R0
00DA  B60F     IN R0, 0x3F
00DB  920F     PUSH R0
00DC  2411     EOR R1, R1
00DD  938F     PUSH R24
00DE  93EF     PUSH R30
00DF  93FF     PUSH R31
19:                if ((RTC.INTFLAGS & RTC_CMP_bm) >0)
00E0  9180     LDS R24, 0x00
00E1  0143     MOVW R8, R6
00E2  FF81     SBRS R24, 1
00E3  C007     RJMP 0xEB
20:                {
21:                    RTC.INTFLAGS = RTC_CMP_bm;
00E4  E4E0     LDI R30, 0x40
00E5  E0F1     LDI R31, 0x01
00E6  E082     LDI R24, 0x02
00E7  8383     STD Z+3, R24
22:                    RTC.INTCTRL &= ~(1 << RTC_CMP_bp);
00E8  8182     LDD R24, Z+2
00E9  7F8D     ANDI R24, 0xFD
00EA  8382     STD Z+2, R24
23:                /* test removed
24:                    Inverter_TX_index=0;
25:                    USART1.TXDATAL = Inverter_TX[0];
26:                */
27:                    
28:            
29:                } 
30:               
31:                if ((RTC.INTFLAGS & RTC_OVF_bm) >0)
00EB  9180     LDS R24, 0x00
00EC  0143     MOVW R8, R6
00ED  FF80     SBRS R24, 0
00EE  C014     RJMP 0x103
32:                {
33:                    /* Insert your RTC Overflow interrupt handling code */
34:            
35:                    Inverter_TX[15]++;
00EF  E2E9     LDI R30, 0x29
00F0  E2F8     LDI R31, 0x28
00F1  8587     LDD R24, Z+15
00F2  5F8F     SUBI R24, 0xFF
00F3  8787     STD Z+15, R24
36:                    if (Inverter_TX[15] >= 60)
00F4  8587     LDD R24, Z+15
00F5  338C     CPI R24, 0x3C
00F6  F048     BRCS 0x100
37:                    {
38:                        Inverter_TX[15] = 0;
00F7  8617     STD Z+15, R1
39:                        Inverter_TX[14]++;
00F8  8586     LDD R24, Z+14
00F9  5F8F     SUBI R24, 0xFF
00FA  8786     STD Z+14, R24
40:                        if (Inverter_TX[14] >= 24)
00FB  8586     LDD R24, Z+14
00FC  3188     CPI R24, 0x18
00FD  F010     BRCS 0x100
41:                        {
42:                            Inverter_TX[14] = 0;
00FE  9210     STS 0x00, R1
43:                        }
44:                    }
45:                    /* Overflow interrupt flag has to be cleared manually */
46:                    RTC.INTFLAGS = RTC_OVF_bm;
0100  E081     LDI R24, 0x01
0101  9380     STS 0x00, R24
0102  0143     MOVW R8, R6
47:                }
48:            }
0103  91FF     POP R31
0104  91EF     POP R30
0105  918F     POP R24
0106  900F     POP R0
0107  BE0F     OUT 0x3F, R0
0108  900F     POP R0
0109  901F     POP R1
010A  9518     RETI
49:            
50:            /* Interrupt service routine for RX complete */
51:            ISR(USART1_RXC_vect)
52:            {
010B  921F     PUSH R1
010C  920F     PUSH R0
010D  B60F     IN R0, 0x3F
010E  920F     PUSH R0
010F  2411     EOR R1, R1
0110  932F     PUSH R18
0111  933F     PUSH R19
0112  938F     PUSH R24
0113  939F     PUSH R25
0114  93EF     PUSH R30
0115  93FF     PUSH R31
53:                uint16_t current_time;
54:                current_time = Inverter_Tick_count;
0116  9180     LDS R24, 0x00
0117  2807     OR R0, R7
0118  9190     LDS R25, 0x00
0119  2808     OR R0, R8
55:                if (current_time >= Inverter_last_bytetime)
011A  9120     LDS R18, 0x00
011B  2812     OR R1, R2
011C  9130     LDS R19, 0x00
011D  2813     OR R1, R3
011E  1782     CP R24, R18
011F  0793     CPC R25, R19
0120  F038     BRCS 0x128
56:                {
57:                    current_time -= Inverter_last_bytetime;
0121  9120     LDS R18, 0x00
0122  2812     OR R1, R2
0123  9130     LDS R19, 0x00
0124  2813     OR R1, R3
0125  1B82     SUB R24, R18
0126  0B93     SBC R25, R19
0127  C008     RJMP 0x130
58:                }
59:                else
60:                {
61:                    current_time += (0xFFFF-Inverter_last_bytetime);
0128  9120     LDS R18, 0x00
0129  2812     OR R1, R2
012A  9130     LDS R19, 0x00
012B  2813     OR R1, R3
012C  9520     COM R18
012D  9530     COM R19
012E  0F82     ADD R24, R18
012F  1F93     ADC R25, R19
62:                }
63:                Inverter_last_bytetime = Inverter_Tick_count;
0130  9120     LDS R18, 0x00
0131  2807     OR R0, R7
0132  9130     LDS R19, 0x00
0133  2808     OR R0, R8
0134  9320     STS 0x00, R18
0135  2812     OR R1, R2
0136  9330     STS 0x00, R19
0137  2813     OR R1, R3
64:                if (current_time > 1)
0138  9702     SBIW R24, 0x02
0139  F060     BRCS 0x146
65:                {
66:                    if (Inverter_RX_index>0)
013A  9180     LDS R24, 0x00
013B  2804     OR R0, R4
013C  2388     AND R24, R24
013D  F019     BREQ 0x141
67:                    {
68:                        Inverter_RX_Error=1;
013E  E081     LDI R24, 0x01
013F  9380     STS 0x00, R24
0140  2811     OR R1, R1
69:                    }
70:                    Inverter_RX_index=0;
0141  9210     STS 0x00, R1
0142  2804     OR R0, R4
71:                    Inverter_Com_stat=RXActive;
0143  E081     LDI R24, 0x01
0144  9380     STS 0x00, R24
0145  2803     OR R0, R3
72:                }
73:                Inverter_RX[Inverter_RX_index] = USART1.RXDATAL;
0146  91E0     LDS R30, 0x00
0147  2804     OR R0, R4
0148  E0F0     LDI R31, 0x00
0149  9180     LDS R24, 0x00
014A  0820     SBC R2, R0
014B  5EEC     SUBI R30, 0xEC
014C  4DF7     SBCI R31, 0xD7
014D  8380     ST Z, R24
74:                Inverter_RX_index++;
014E  9180     LDS R24, 0x00
014F  2804     OR R0, R4
0150  5F8F     SUBI R24, 0xFF
0151  9380     STS 0x00, R24
0152  2804     OR R0, R4
75:                if (Inverter_RX_index >= 20)  
0153  9180     LDS R24, 0x00
0154  2804     OR R0, R4
0155  3184     CPI R24, 0x14
0156  F028     BRCS 0x15C
76:                {
77:                    Inverter_RX_index=0;
0157  9210     STS 0x00, R1
0158  2804     OR R0, R4
78:                    Inverter_Com_stat=RXComplete;
0159  E083     LDI R24, 0x03
015A  9380     STS 0x00, R24
015B  2803     OR R0, R3
79:                }            
80:            }
015C  91FF     POP R31
015D  91EF     POP R30
015E  919F     POP R25
015F  918F     POP R24
0160  913F     POP R19
0161  912F     POP R18
0162  900F     POP R0
0163  BE0F     OUT 0x3F, R0
0164  900F     POP R0
0165  901F     POP R1
0166  9518     RETI
81:            
82:            /* Interrupt service routine for Data Register Empty */
83:            ISR(USART1_DRE_vect)
84:            {
0167  921F     PUSH R1
0168  920F     PUSH R0
0169  B60F     IN R0, 0x3F
016A  920F     PUSH R0
016B  2411     EOR R1, R1
016C  938F     PUSH R24
016D  93EF     PUSH R30
016E  93FF     PUSH R31
85:                Inverter_TX_index++;
016F  9180     LDS R24, 0x00
0170  2805     OR R0, R5
0171  5F8F     SUBI R24, 0xFF
0172  9380     STS 0x00, R24
0173  2805     OR R0, R5
86:                if (Inverter_TX_index < 20){
0174  9180     LDS R24, 0x00
0175  2805     OR R0, R5
0176  3184     CPI R24, 0x14
0177  F448     BRCC 0x181
87:                    USART1.TXDATAL = Inverter_TX[Inverter_TX_index];
0178  91E0     LDS R30, 0x00
0179  2805     OR R0, R5
017A  E0F0     LDI R31, 0x00
017B  5DE7     SUBI R30, 0xD7
017C  4DF7     SBCI R31, 0xD7
017D  8180     LD R24, Z
017E  9380     STS 0x00, R24
017F  0822     SBC R2, R2
0180  C008     RJMP 0x189
88:                }
89:                else {
90:                    USART1.CTRLA &= ~(1 << USART_DREIE_bp);
0181  E2E0     LDI R30, 0x20
0182  E0F8     LDI R31, 0x08
0183  8185     LDD R24, Z+5
0184  7D8F     ANDI R24, 0xDF
0185  8385     STD Z+5, R24
91:                    Inverter_Com_stat=TXComplete;
0186  E084     LDI R24, 0x04
0187  9380     STS 0x00, R24
0188  2803     OR R0, R3
92:                }
93:                
94:            }
0189  91FF     POP R31
018A  91EF     POP R30
018B  918F     POP R24
018C  900F     POP R0
018D  BE0F     OUT 0x3F, R0
018E  900F     POP R0
018F  901F     POP R1
0190  9518     RETI
95:            
96:            /**
97:             * \brief Initialize rtc interface
98:             * \return Initialization status.
99:             */
100:           void RTC_0_init(void)
101:           {
102:           
103:           	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
0191  E4E0     LDI R30, 0x40
0192  E0F1     LDI R31, 0x01
0193  8181     LDD R24, Z+1
0194  1181     CPSE R24, R1
0195  CFFD     RJMP 0x193
104:           	}
105:           
106:           	// RTC.CMP = 0x0; /* Compare: 0x0 */
107:           
108:           	// RTC.CNT = 0x0; /* Counter: 0x0 */
109:           
110:           	RTC.CTRLA = RTC_PRESCALER_DIV32_gc  /* 32 */
0196  E4E0     LDI R30, 0x40
0197  E0F1     LDI R31, 0x01
0198  EA89     LDI R24, 0xA9
0199  8380     ST Z, R24
111:           	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
112:           	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */
113:           
114:           	RTC.PER = 0xefff; /* Period: 0xefff */
019A  EF8F     LDI R24, 0xFF
019B  EE9F     LDI R25, 0xEF
019C  8782     STD Z+10, R24
019D  8793     STD Z+11, R25
115:           
116:           	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */
117:           
118:           	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
019E  E081     LDI R24, 0x01
019F  8385     STD Z+5, R24
119:           
120:           	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
01A0  8382     STD Z+2, R24
01A1  9508     RET
121:           	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */
122:           
123:           	// RTC.PITCTRLA = RTC_PERIOD_OFF_gc /* Off */
124:           	//		 | 0 << RTC_PITEN_bp; /* Enable: disabled */
125:           
126:           	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */
127:           
128:           	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */
129:           
130:           }
131:           
132:           /**
133:            * \brief Initialize USART interface
134:            * If module is configured to disabled state, the clock to the USART is disabled
135:            * if this is supported by the device's clock system.
136:            *
137:            * \return Initialization status.
138:            * \retval 0 the USART init was successful
139:            * \retval 1 the USART init was not successful
140:            */
141:           void USART_1_init(void)
142:           {
143:               PORTC.DIRSET = 1 << PORT0;
01A2  E4E0     LDI R30, 0x40
01A3  E0F4     LDI R31, 0x04
01A4  E081     LDI R24, 0x01
01A5  8381     STD Z+1, R24
144:               PORTC.OUTSET = 0 << PORT0;
01A6  8215     STD Z+5, R1
145:               PORTC.DIRSET = 1 << PORT3;
01A7  E088     LDI R24, 0x08
01A8  8381     STD Z+1, R24
146:               PORTC.OUTSET = 0 << PORT3;
01A9  8215     STD Z+5, R1
147:           
148:           	USART1.BAUD = (uint16_t)USART1_BAUD_RATE(19200); /* set baud rate register */
01AA  E2E0     LDI R30, 0x20
01AB  E0F8     LDI R31, 0x08
01AC  E283     LDI R24, 0x23
01AD  E098     LDI R25, 0x08
01AE  8780     STD Z+8, R24
01AF  8791     STD Z+9, R25
149:           
150:           	USART1.CTRLA = 0 << USART_ABEIE_bp    /* Auto-baud Error Interrupt Enable: disabled */
01B0  E882     LDI R24, 0x82
151:           	               | 0 << USART_DREIE_bp  /* Data Register Empty Interrupt Enable: disabled */
152:           	               | 0 << USART_LBME_bp   /* Loop-back Mode Enable: disabled */
153:           	               | USART_RS485_INT_gc   /* RS485 Mode disabled */
154:           	               | 1 << USART_RXCIE_bp  /* Receive Complete Interrupt Enable: enabled */
155:           	               | 0 << USART_RXSIE_bp  /* Receiver Start Frame Interrupt Enable: disabled */
156:           	               | 0 << USART_TXCIE_bp; /* Transmit Complete Interrupt Enable: disabled */
157:           
158:           	USART1.CTRLB = 0 << USART_MPCM_bp       /* Multi-processor Communication Mode: disabled */
01B2  EC80     LDI R24, 0xC0
01B3  8386     STD Z+6, R24
01B4  9508     RET
159:           	               | 0 << USART_ODME_bp     /* Open Drain Mode Enable: disabled */
160:           	               | 1 << USART_RXEN_bp     /* Reciever enable: enabled */
161:           	               | USART_RXMODE_NORMAL_gc /* Normal mode */
162:           	               | 0 << USART_SFDEN_bp    /* Start Frame Detection Enable: disabled */
163:           	               | 1 << USART_TXEN_bp;    /* Transmitter Enable: enabled */
164:           
165:           	// USART1.CTRLC = USART_CMODE_ASYNCHRONOUS_gc /* Asynchronous Mode */
166:           	//		 | USART_CHSIZE_8BIT_gc /* Character size: 8 bit */
167:           	//		 | USART_PMODE_DISABLED_gc /* No Parity */
168:           	//		 | USART_SBMODE_1BIT_gc; /* 1 stop bit */
169:           
170:           	// USART1.DBGCTRL = 0 << USART_DBGRUN_bp; /* Debug Run: disabled */
171:           
172:           	// USART1.EVCTRL = 0 << USART_IREI_bp; /* IrDA Event Input Enable: disabled */
173:           
174:           	// USART1.RXPLCTRL = 0x0 << USART_RXPL_gp; /* Receiver Pulse Length: 0x0 */
175:           
176:           	// USART1.TXPLCTRL = 0x0 << USART_TXPL_gp; /* Transmit pulse length: 0x0 */
177:           
178:           }
179:           
180:           /**
181:            * \brief Enable RX and TX in USART_0
182:            * 1. If supported by the clock system, enables the clock to the USART
183:            * 2. Enables the USART module by setting the RX and TX enable-bits in the USART control register
184:            *
185:            * \return Nothing
186:            */
187:           void USART_1_enable(void)
188:           {
189:           	USART1.CTRLB |= USART_RXEN_bm | USART_TXEN_bm;
190:           }
191:           
192:           /**
193:            * \brief Enable RX in USART_0
194:            * 1. If supported by the clock system, enables the clock to the USART
195:            * 2. Enables the USART module by setting the RX enable-bit in the USART control register
196:            *
197:            * \return Nothing
198:            */
199:           void USART_1_enable_rx(void)
200:           {
201:           	USART1.CTRLB |= USART_RXEN_bm;
202:           }
203:           
204:           /**
205:            * \brief Enable TX in USART_0
206:            * 1. If supported by the clock system, enables the clock to the USART
207:            * 2. Enables the USART module by setting the TX enable-bit in the USART control register
208:            *
209:            * \return Nothing
210:            */
211:           void USART_1_enable_tx(void)
212:           {
213:           	USART1.CTRLB |= USART_TXEN_bm;
214:           }
215:           
216:           /**
217:            * \brief Disable USART_0
218:            * 1. Disables the USART module by clearing the enable-bit(s) in the USART control register
219:            * 2. If supported by the clock system, disables the clock to the USART
220:            *
221:            * \return Nothing
222:            */
223:           void USART_1_disable(void)
224:           {
225:           	USART1.CTRLB &= ~(USART_RXEN_bm | USART_TXEN_bm);
226:           }
227:           
228:           /**
229:            * \brief Get recieved data from USART_0
230:            *
231:            * \return Data register from USART_0 module
232:            */
233:           uint8_t USART_1_get_data(void)
234:           {
235:           	return USART1.RXDATAL;
236:           }
237:           
238:           void INVERTER_init(void){
239:               USART_1_init();
01B5  940E     CALL modbusGetAddress
01B6  01A2     MOVW R20, R4
240:               RTC_0_init();
01B7  940E     CALL modbusGetAddress
01B8  0191     MOVW R18, R2
01B9  9508     RET
241:           }
242:           
243:           void INVERTER_tick(void){
244:               Inverter_Tick_count++;
01BA  9180     LDS R24, 0x00
01BB  2807     OR R0, R7
01BC  9190     LDS R25, 0x00
01BD  2808     OR R0, R8
01BE  9601     ADIW R24, 0x01
01BF  9380     STS 0x00, R24
01C0  2807     OR R0, R7
01C1  9390     STS 0x00, R25
01C2  2808     OR R0, R8
245:               
246:               switch (Inverter_Com_stat){
01C3  9180     LDS R24, 0x00
01C4  2803     OR R0, R3
01C5  3083     CPI R24, 0x03
01C6  F019     BREQ 0x1CA
01C7  3084     CPI R24, 0x04
01C8  F0B1     BREQ 0x1DF
01C9  9508     RET
247:                   case RXComplete: {
248:                       Inverter_Com_count++;
01CA  9180     LDS R24, 0x00
01CB  2806     OR R0, R6
01CC  5F8F     SUBI R24, 0xFF
01CD  9380     STS 0x00, R24
01CE  2806     OR R0, R6
249:                       if (Inverter_Com_count >= 10) {
01CF  9180     LDS R24, 0x00
01D0  2806     OR R0, R6
01D1  308A     CPI R24, 0x0A
01D2  F070     BRCS 0x1E1
250:                           Inverter_Com_count=0;
01D3  9210     STS 0x00, R1
01D4  2806     OR R0, R6
251:                           Inverter_Com_stat=TXActive;
01D5  E082     LDI R24, 0x02
01D6  9380     STS 0x00, R24
01D7  2803     OR R0, R3
252:                           Inverter_TX_index=0;
01D8  9210     STS 0x00, R1
01D9  2805     OR R0, R5
253:                           USART1.TXDATAL = Inverter_TX[0];
01DA  9180     LDS R24, 0x00
01DB  2829     OR R2, R9
01DC  9380     STS 0x00, R24
01DD  0822     SBC R2, R2
01DE  9508     RET
254:                       
255:                           //USART1.CTRLA |= 1 << USART_DREIE_bp;
256:                       }
257:                   } break;
258:                   
259:                   case TXComplete: {
260:                       Inverter_Com_stat=RXStandby;
01DF  9210     STS 0x00, R1
01E0  2803     OR R0, R3
01E1  9508     RET
261:                       
262:                   } break;
263:           
264:                   default: {
265:                   } break;
266:               }
267:           }
---  ././././crt1/gcrt1.S  ------------------------------------------------------------------------------
0000  940C     JMP modbusGetAddress
0002  940C     JMP modbusGetAddress
0004  940C     JMP modbusGetAddress
0006  940C     JMP modbusGetAddress
0008  940C     JMP modbusGetAddress
000A  940C     JMP modbusGetAddress
000C  940C     JMP modbusGetAddress
000E  940C     JMP modbusGetAddress
0010  940C     JMP modbusGetAddress
0012  940C     JMP modbusGetAddress
0014  940C     JMP modbusGetAddress
0016  940C     JMP modbusGetAddress
0018  940C     JMP modbusGetAddress
001A  940C     JMP modbusGetAddress
001C  940C     JMP modbusGetAddress
001E  940C     JMP modbusGetAddress
0020  940C     JMP modbusGetAddress
0022  940C     JMP modbusGetAddress
0024  940C     JMP modbusGetAddress
0026  940C     JMP modbusGetAddress
0028  940C     JMP modbusGetAddress
002A  940C     JMP modbusGetAddress
002C  940C     JMP modbusGetAddress
002E  940C     JMP modbusGetAddress
0030  940C     JMP modbusGetAddress
0032  940C     JMP modbusGetAddress
0034  940C     JMP modbusGetAddress
0036  940C     JMP modbusGetAddress
0038  940C     JMP modbusGetAddress
003A  940C     JMP modbusGetAddress
003C  940C     JMP modbusGetAddress
003E  940C     JMP modbusGetAddress
0040  940C     JMP modbusGetAddress
0042  940C     JMP modbusGetAddress
0044  940C     JMP modbusGetAddress
0046  940C     JMP modbusGetAddress
0048  940C     JMP modbusGetAddress
004A  940C     JMP modbusGetAddress
004C  940C     JMP modbusGetAddress
004E  940C     JMP modbusGetAddress
007D  940C     JMP modbusGetAddress
0060  2411     EOR R1, R1
0061  BE1F     OUT 0x3F, R1
0062  EFCF     LDI R28, 0xFF
0063  BFCD     OUT 0x3D, R28
0064  E3DF     LDI R29, 0x3F
0065  BFDE     OUT 0x3E, R29
0079  940E     CALL modbusGetAddress
007B  940C     JMP modbusGetAddress
